<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Serif+Pro:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CIBM+Plex+Mono+Light:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"simuleite.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Mysql体系结构  DB与Instance DB：数据库可以是ibd文件、放在内存的文件，是物理操作系统文件或其他形式文件类型的集合。 Instance：Mysql数据库由后台线程及一个共享内存区组成。  数据库实例才是真正操作数据库文件的。在集群情况下，可能存在一个DB被多个Instance使用的情况。  Mysql被设计为单进程多线程，在OS上的表现是一个进程。  插件式表存储引擎  存储">
<meta property="og:type" content="article">
<meta property="og:title" content="InnoDB原理">
<meta property="og:url" content="http://simuleite.github.io/ComputerScience/%E7%9F%A5%E8%AF%86/InnoDB%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="SMULET&#39;s BLOG">
<meta property="og:description" content="Mysql体系结构  DB与Instance DB：数据库可以是ibd文件、放在内存的文件，是物理操作系统文件或其他形式文件类型的集合。 Instance：Mysql数据库由后台线程及一个共享内存区组成。  数据库实例才是真正操作数据库文件的。在集群情况下，可能存在一个DB被多个Instance使用的情况。  Mysql被设计为单进程多线程，在OS上的表现是一个进程。  插件式表存储引擎  存储">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-22T01:50:19.306Z">
<meta property="article:author" content="SIMULEITE">
<meta property="article:tag" content="知识">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://simuleite.github.io/ComputerScience/%E7%9F%A5%E8%AF%86/InnoDB%E5%8E%9F%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://simuleite.github.io/ComputerScience/%E7%9F%A5%E8%AF%86/InnoDB%E5%8E%9F%E7%90%86/","path":"ComputerScience/知识/InnoDB原理/","title":"InnoDB原理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>InnoDB原理 | SMULET's BLOG</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="SMULET's BLOG" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SMULET's BLOG</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-技术链"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>技术链</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-知识库"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>知识库</a></li><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text"> Mysql体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#db%E4%B8%8Einstance"><span class="nav-text"> DB与Instance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%BC%8F%E8%A1%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-text"> 插件式表存储引擎</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-text"> 索引原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-text"> 索引分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text"> 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-text"> 功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text"> 存储方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E6%93%8E"><span class="nav-text"> 引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88innodb%E5%BB%BA%E8%AE%AE%E6%AF%8F%E5%BC%A0%E8%A1%A8%E5%BF%85%E9%A1%BB%E5%BB%BA%E7%AB%8B%E4%B8%BB%E9%94%AE%E5%B9%B6%E7%94%A8%E8%87%AA%E5%A2%9E%E6%95%B4%E5%9E%8B"><span class="nav-text"> 为什么InnoDB建议每张表必须建立主键，并用自增整型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b%E6%A0%91%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-text"> B+树如何支持范围查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-text"> 联合主键索引，为什么是最左前缀原则？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="nav-text"> 索引优化原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#explain%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text"> explain性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A"><span class="nav-text"> 字段解释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="nav-text"> sql语句优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-text"> 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-text"> 索引下推</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#trace%E5%B7%A5%E5%85%B7"><span class="nav-text"> Trace工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#order-by%E4%B8%8Egroup-by"><span class="nav-text"> Order by与Group by</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#orderby%E6%80%BB%E7%BB%93"><span class="nav-text"> orderby总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#filesort%E5%8E%9F%E7%90%86"><span class="nav-text"> FileSort原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="nav-text"> 如何设计索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-text"> 什么时候建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%B0%BD%E9%87%8F%E8%A6%86%E7%9B%96%E6%9D%A1%E4%BB%B6"><span class="nav-text"> 联合索引尽量覆盖条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E5%9F%BA%E5%AD%97%E6%AE%B5%E4%B8%8D%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-text"> 小基字段不建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%A8%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-text"> 长字符串用前缀索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E6%BB%A1%E8%B6%B3where%E8%80%8C%E4%B8%8D%E6%98%AForderby"><span class="nav-text"> 优先满足where，而不是orderby</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%8E%A7%E5%8F%B0%E8%AF%86%E5%88%AB%E6%85%A2sql%E9%92%88%E5%AF%B9%E6%80%A7%E5%81%9A%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-text"> 在控台识别慢sql，针对性做索引优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE%E6%94%BE%E6%9C%80%E5%90%8E"><span class="nav-text"> 范围查找放最后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8F%8D%E5%90%91%E4%BC%98%E5%8C%96sql"><span class="nav-text"> 根据设计的索引反向优化sql</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%A4%9A%E5%86%99%E5%B0%91%E5%8F%AF%E4%BB%A5%E5%A4%9A%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%86%99%E5%A4%9A%E5%B0%B1%E8%A6%81%E5%B0%91%E5%BB%BA"><span class="nav-text"> 读多写少可以多建索引，写多就要少建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-text"> 分页索引优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join%E8%A1%A8%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-text"> Join表关联查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nlj%E7%AE%97%E6%B3%95%E6%9C%89%E7%B4%A2%E5%BC%95"><span class="nav-text"> NLJ算法（有索引）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bnl%E7%AE%97%E6%B3%95%E6%97%A0%E7%B4%A2%E5%BC%95"><span class="nav-text"> BNL算法（无索引）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in%E4%B8%8Eexist"><span class="nav-text"> in与exist</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#in%E5%AD%90%E5%8F%A5%E5%86%85%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%9A%E5%85%88%E6%89%A7%E8%A1%8C"><span class="nav-text"> in子句内的查询会先执行。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exists%E5%A4%96%E5%B1%82%E7%9A%84%E8%AF%AD%E5%8F%A5%E4%BC%9A%E5%85%88%E6%89%A7%E8%A1%8C"><span class="nav-text"> exists外层的语句会先执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#count"><span class="nav-text"> count</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-text"> 什么时候分库分表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%A7%84%E7%BA%A6"><span class="nav-text"> 索引规约</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81"><span class="nav-text"> 事务和锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text"> 并发事务处理的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text"> 隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-text"> 锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-%E6%9F%90%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="nav-text"> 间隙锁 某些情况下解决幻读问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81"><span class="nav-text"> 临键锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-text"> 行锁分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93"><span class="nav-text"> 锁优化总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mvcc"><span class="nav-text"> MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undo%E6%97%A5%E5%BF%97"><span class="nav-text"> undo日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#read-view"><span class="nav-text"> read-view</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mysql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text"> Mysql执行过程</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SIMULEITE</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://simuleite.github.io/ComputerScience/%E7%9F%A5%E8%AF%86/InnoDB%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SIMULEITE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SMULET's BLOG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="InnoDB原理 | SMULET's BLOG">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          InnoDB原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-25T00:00:00+08:00">2025-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-22 09:50:19" itemprop="dateModified" datetime="2025-05-22T09:50:19+08:00">2025-05-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="mysql体系结构"><a class="markdownIt-Anchor" href="#mysql体系结构"></a> Mysql体系结构</h1>
<h2 id="db与instance"><a class="markdownIt-Anchor" href="#db与instance"></a> DB与Instance</h2>
<p>DB：数据库可以是ibd文件、放在内存的文件，是物理操作系统文件或其他形式文件类型的集合。<br />
Instance：Mysql数据库由后台线程及一个共享内存区组成。</p>
<blockquote>
<p>数据库实例才是真正操作数据库文件的。在集群情况下，可能存在一个DB被多个Instance使用的情况。</p>
</blockquote>
<p>Mysql被设计为单进程多线程，在OS上的表现是一个进程。</p>
<h2 id="插件式表存储引擎"><a class="markdownIt-Anchor" href="#插件式表存储引擎"></a> 插件式表存储引擎</h2>
<blockquote>
<p>存储引擎基于表，而不是DB。</p>
</blockquote>
<blockquote>
<p>存储引擎对开发人员透明。</p>
</blockquote>
<h1 id="索引原理"><a class="markdownIt-Anchor" href="#索引原理"></a> 索引原理</h1>
<p>MySQL使用的是B+树作为索引的数据结构</p>
<blockquote>
<p>B树是一个分支内<strong>按顺序</strong>存放多个节点数据的数据结构；而B+树在此基础上，在分支内只存储索引，只在叶子节点存储数据（这样每一层可以存储更多索引，减少层数），并且在叶节点之间用指针互相连接，提高访问效率。</p>
</blockquote>
<h2 id="索引分类"><a class="markdownIt-Anchor" href="#索引分类"></a> 索引分类</h2>
<h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2>
<ul>
<li>B+树索引</li>
<li>哈希索引</li>
<li>红黑树索引</li>
</ul>
<h2 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h2>
<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>普通索引（一般我们为优化sql建立的索引）</li>
<li>全文索引</li>
<li>联合索引</li>
</ul>
<h2 id="存储方式"><a class="markdownIt-Anchor" href="#存储方式"></a> 存储方式</h2>
<ul>
<li>聚簇索引</li>
<li>非聚簇索引（索引与数据分开，需要回表）</li>
</ul>
<span id="more"></span>
<h2 id="引擎"><a class="markdownIt-Anchor" href="#引擎"></a> 引擎</h2>
<p>MyISAM，B+树存储的Data就是数据的地址（非聚集索引、稀疏索引）<br />
InnoDB，直接存储数据（聚集索引）</p>
<h2 id="为什么innodb建议每张表必须建立主键并用自增整型"><a class="markdownIt-Anchor" href="#为什么innodb建议每张表必须建立主键并用自增整型"></a> 为什么InnoDB建议每张表必须建立主键，并用自增整型？</h2>
<p>ibd必须用B+树索引，而整型是天然的索引；否则ibd会自己维护一个唯一id行（隐藏的主键）。<br />
因此UUID比较效率会比整型更低。<br />
而自增则根本避免了重复，并且只在一端变化，已经有的数据无需做修改，减少了维持有序的成本。<br />
如果不自增，而是随机添加，那么新增的数很可能会触发分裂、平衡，造成冗余索引。</p>
<h2 id="b树如何支持范围查询"><a class="markdownIt-Anchor" href="#b树如何支持范围查询"></a> B+树如何支持范围查询</h2>
<p>Hash结构的索引，不支持范围查询；而B+树只用找到两端，然后顺着指针拿到所有节点就好了（叶节点是双指针连接的，并且有序）。</p>
<h2 id="联合主键索引为什么是最左前缀原则"><a class="markdownIt-Anchor" href="#联合主键索引为什么是最左前缀原则"></a> 联合主键索引，为什么是最左前缀原则？</h2>
<p>最左前缀原则：不能跳过左边的索引，必须从最左边索引开始，逐步增加条件。<br />
因为联合主键索引底层的B+树就是按照主键顺序排序的，会从左到右进行比较；如果跳过了左边的主键，那就找不到了，因为第二个主键不一定是排好序的！。<br />
首先按照第一个主键排序，然后按照第二个主键排序。在同一个主键内，二级主键是有序的，但是跳出这个圈，就是无序的。</p>
<h2 id="索引优化原则"><a class="markdownIt-Anchor" href="#索引优化原则"></a> 索引优化原则</h2>
<ul>
<li>首先开启慢sql日志，找到执行缓慢的sql语句。</li>
<li>接着使用explain分析性能，重点关注type（连接类型，有没有全表扫描）、key（有没有走索引）、rows（扫描行数是否过大）、Extra（是否使用文件排序、临时表）。</li>
<li>检查是否建立了索引、语句是否遵从索引最左前缀原则、是不是表达式有问题导致没走索引。</li>
<li>减少sql查询量，不是全表扫描，只查询需要的字段（覆盖索引）。</li>
<li>检查表设计是不是有问题，有没有大field；关联查询比较多，那就设计冗余。</li>
</ul>
<h3 id="explain性能分析"><a class="markdownIt-Anchor" href="#explain性能分析"></a> explain性能分析</h3>
<p><code>explain extended</code>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mi>s</mi><mo>∗</mo><mi>f</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi mathvariant="normal">/</mi><mn>100</mn></mrow><annotation encoding="application/x-tex">rows * filtered/100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>可以估算出将要和explain中前一个表达式进行连接的行数。<br />
<code>show warning</code>: Mysql的提示信息，可能会帮你优化。</p>
<h4 id="字段解释"><a class="markdownIt-Anchor" href="#字段解释"></a> 字段解释</h4>
<p>select_type</p>
<ul>
<li>Primary 最外层的select。</li>
<li>Subquery 不在from语句中，包含在select中的子查询。</li>
<li>Derived 包含在from语句中的子查询。派生表。<br />
id</li>
<li>表示执行顺序，顺序越靠后优先级越高<br />
<strong>type</strong><br />
效率优先级 system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</li>
</ul>
<blockquote>
<p>一般来说range是及格线，最好达到ref</p>
</blockquote>
<ul>
<li>NULL mysql通过优化和底层原理，不访问表或索引就取到值。如求最小值，通过B+树直接拿到。</li>
<li>system, const system是const的特例，const表示常量查询。表只有一行，为const查询。只有一条元组匹配，为system查询。</li>
<li>eq_ref 主键关联查询，表有几行。</li>
<li>ref 使用非主键（不唯一）索引，表有很多行。使用普通索引或唯一索引的部分前缀。</li>
<li>range 范围查找，包括比较符号。</li>
<li>index 无查询条件，全选。扫描全索引就能拿到结果，一般扫描二级索引（Mysql优先选择同等条件下更小的索引）。</li>
<li>ALL 全表扫描。扫描聚集索引，比index更大</li>
</ul>
<h3 id="sql语句优化"><a class="markdownIt-Anchor" href="#sql语句优化"></a> sql语句优化</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> your_table <span class="keyword">where</span> a <span class="operator">&gt;</span> cond1 <span class="keyword">and</span> b <span class="operator">=</span> cond2 <span class="keyword">and</span> c <span class="operator">=</span> cond3</span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> your_table <span class="keyword">where</span> a <span class="operator">=</span> cond1 <span class="keyword">and</span> b <span class="operator">&gt;</span> cond2 <span class="keyword">and</span> c <span class="operator">=</span> cond3</span><br></pre></td></tr></table></figure>
<p>第一张表，第一个索引就开始范围查询，sql会认为范围太大，<strong>不走索引</strong>。<br />
第二张表，第二个索引才开始范围查询，在合理范围内，会走索引。</p>
<ul>
<li>尽量使用覆盖索引，这样会走索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 推荐，其中name和age都有索引</span></span><br><span class="line"><span class="keyword">select</span> name, age <span class="keyword">from</span> your_table <span class="keyword">where</span> <span class="keyword">condition</span></span><br><span class="line"><span class="comment">-- 不推荐</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> your_table <span class="keyword">where</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>
<ul>
<li>少用or或in；不对索引用函数；不让索引发生隐式转换</li>
<li>减少搜索范围；范围过大，mysql会认为全表扫描更快，从而不走索引</li>
<li><code>force index(your_index)</code> 强制索引（注意，不一定更快！可能更多回表）</li>
<li>试试用<code>like</code>代替范围查询</li>
</ul>
<h2 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h2>
<p>Mysql8以后移除了缓存。</p>
<blockquote>
<p>Mysql缓存的本质是KV Map。然而，对于高频修改的数据，Map缓存下来的是<strong>脏数据</strong>，因此不实用。</p>
</blockquote>
<h2 id="索引下推"><a class="markdownIt-Anchor" href="#索引下推"></a> 索引下推</h2>
<p>在mysql5.6以后，每过滤一条数据，同时还会比较其他条件，只回表符合条件的主键，减少数据量。<br />
<code>like</code>基本上会走索引下推。</p>
<h2 id="trace工具"><a class="markdownIt-Anchor" href="#trace工具"></a> Trace工具</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启trace</span></span><br><span class="line"><span class="keyword">set</span> session optmizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="comment">-- 执行你的语句后，执行下面语句查询TRACE即为sql执行情况</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.OPTIMIZER_TRACE;</span><br></pre></td></tr></table></figure>
<p><code>rows_estimation: cost</code>就是扫描成本。<br />
<code>considered_execution_plans</code>是最终考虑的执行计划。</p>
<h2 id="order-by与group-by"><a class="markdownIt-Anchor" href="#order-by与group-by"></a> Order by与Group by</h2>
<p><code>key_len</code>分析走了什么索引：</p>
<ul>
<li>int 4字节</li>
<li>char(n) n字节</li>
<li>varchar(n) n+2字节，其中2字节用于存储长度</li>
<li>null 允许为null，会再用1字节存储<br />
根据上面知识，可以根据索引类型反推使用了什么索引。</li>
</ul>
<p><code>order by</code>不会走索引。只看前面<code>where</code>语句用到的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * where a = cond1 and c = cond3 order by b;</span><br><span class="line">select * where a = cond1 orderby c;</span><br></pre></td></tr></table></figure>
<p><code>c</code>对应第三个索引。上面两条语句，第一条只走a索引，用b、c索引排序；第二条用a索引，不用索引排序，而是文件排序。因为跳过了索引b，c是无序存储的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * where a = cond1 order by b, c;</span><br><span class="line">select * where a = cond1 order by c, b;</span><br><span class="line">select * where a = cond1 and b = cond order by b, c;</span><br><span class="line">select * where a = cond1 order by b asc, c desc;</span><br></pre></td></tr></table></figure>
<p>上面第一条语句走a索引，会用bc排序，因为底层存储是有序的。第二条不走索引，因为顺序不对！<br />
第三条会用ab索引，因为b条件是个常量，不需要orderby c，被mysql优化了；<br />
第四条走a索引，不用bc排序，因为底层是升序排序，而desc变成降序了。（mysql8以后有降序索引支持）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * where a in (cond1.1, cond1.2) order by b, c;</span><br></pre></td></tr></table></figure>
<p>不走索引，filesort，因为多个查询条件，在需要orderby排序时相当于范围索引。</p>
<h2 id="orderby总结"><a class="markdownIt-Anchor" href="#orderby总结"></a> orderby总结</h2>
<ol>
<li>orderby按照最左前缀，或orderby与where子句结合且满足最左前缀时，会走索引。<br />
groupby与orderby基本相同，实质也是先排序后分组。可以使用<code>order by null</code>禁用排序，加速过程。</li>
</ol>
<h2 id="filesort原理"><a class="markdownIt-Anchor" href="#filesort原理"></a> FileSort原理</h2>
<ul>
<li>单路排序：一次性取出满足条件的所有字段，然后在sort buffer中进行排序；trace可以看到sort_mode: &lt;sort_key, additional_key&gt;。</li>
<li>双路排序：回表排序，只用排序字段和行id在sort buffer排序，trace可以看到&lt;sort_key, rowid&gt;。占用空间会少一点，因为只用到了特定的排序字段。因为没有取出所有数据，排序完成后，还要拿id回表查询所有数据。</li>
</ul>
<p>Mysql有系统变量<code>max_length_for_sort_data</code>，默认1024Byte。如果大于它，用双路排序模式；小于则使用单路排序可以。</p>
<h2 id="如何设计索引"><a class="markdownIt-Anchor" href="#如何设计索引"></a> 如何设计索引</h2>
<h3 id="什么时候建索引"><a class="markdownIt-Anchor" href="#什么时候建索引"></a> 什么时候建索引</h3>
<p>不是建完表就想当然地建索引，而是后来根据用户使用最频繁的字段建索引。<br />
在主体功能开发完后，把使用到的所有sql语句拉出来分析，然后建索引。</p>
<h3 id="联合索引尽量覆盖条件"><a class="markdownIt-Anchor" href="#联合索引尽量覆盖条件"></a> 联合索引尽量覆盖条件</h3>
<p>少建单值索引（联合索引可以过滤更多字段，而且sql一般只会用1个索引），设计1-3个联合索引包含sql的where、orderby、groupby字段，索引顺序满足sql语句的最左前缀原则。<br />
对于unique，确保无重复的字段，可以建单值索引。</p>
<h3 id="小基字段不建索引"><a class="markdownIt-Anchor" href="#小基字段不建索引"></a> 小基字段不建索引</h3>
<p>例如枚举字段，一共就几个不同的值，建了索引，范围太大，还是需要全表扫描。</p>
<h3 id="长字符串用前缀索引"><a class="markdownIt-Anchor" href="#长字符串用前缀索引"></a> 长字符串用前缀索引</h3>
<p>尽量对占用空间小的列设计索引，如tinyint，也不占存储空间；<br />
对于varchar(255)这样的字段，可以将每个值的前20个字符放在索引树中，如<code>KEY index(name(20), age)</code>。<br />
但是注意，前缀索引只在where有效（而且需要回表），对于orderby、groupby还是要重新排序的。</p>
<h3 id="优先满足where而不是orderby"><a class="markdownIt-Anchor" href="#优先满足where而不是orderby"></a> 优先满足where，而不是orderby</h3>
<p>大多数情况我们会用where筛选出少量数据，然后再排序；这样效率更高。</p>
<h3 id="在控台识别慢sql针对性做索引优化"><a class="markdownIt-Anchor" href="#在控台识别慢sql针对性做索引优化"></a> 在控台识别慢sql，针对性做索引优化</h3>
<p>根据mysql慢查询日志（要手动设置，会影响性能），<code>long_query_time</code>默认是10秒钟</p>
<h3 id="范围查找放最后"><a class="markdownIt-Anchor" href="#范围查找放最后"></a> 范围查找放最后</h3>
<p>不放最后，那很多情况下索引不满足有序条件</p>
<h3 id="根据设计的索引反向优化sql"><a class="markdownIt-Anchor" href="#根据设计的索引反向优化sql"></a> 根据设计的索引反向优化sql</h3>
<p>比如有索引<code>province, city, sex, hobby, age</code><br />
age索引不一定能用到，因为sex和hobby会过滤一批。但是我们可以把sex和hobby手动写sql为全选，这样就能走到age。注意，<strong>必须是基数小的情况才可以这么做</strong>。不过一般生产环境数据量都很大，这么做值得。<br />
在比如统计最近一周的活跃用户，但是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from your_table where province = cond and sex in (&#x27;female&#x27;, &#x27;male&#x27;) and age &gt;= x and age &lt;= y and login_time &gt;= time</span><br></pre></td></tr></table></figure>
<p>这里login_time用不了索引。<br />
可以设计一个标志，7天内是否登录，然后将这个标志作为索引字段，放age前面。<br />
再根据其他高频场景建立辅助索引。</p>
<h3 id="读多写少可以多建索引写多就要少建"><a class="markdownIt-Anchor" href="#读多写少可以多建索引写多就要少建"></a> 读多写少可以多建索引，写多就要少建</h3>
<h2 id="分页索引优化"><a class="markdownIt-Anchor" href="#分页索引优化"></a> 分页索引优化</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> your_table limit <span class="number">90000</span>, <span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> your_table <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">90000</span> limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>第一条语句实际上会从1顺序找到90000，然后把前面的数据删除，所以会出现翻页到后面越来越慢的情况。<br />
第二条语句就能利用索引。但是前提是主键必须是自增而且连续的，例如中间被删除断号了那就不行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> your_table <span class="keyword">as</span> t <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> your_table <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">90000</span>, <span class="number">5</span>) <span class="keyword">as</span> tc <span class="keyword">on</span> t.id <span class="operator">=</span> tc.id</span><br></pre></td></tr></table></figure>
<ul>
<li>覆盖索引再回表：利用覆盖索引找出一个小的结果集，再回表，会尽可能地利用索引。</li>
</ul>
<h2 id="join表关联查询优化"><a class="markdownIt-Anchor" href="#join表关联查询优化"></a> Join表关联查询优化</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id</span><br></pre></td></tr></table></figure>
<h3 id="nlj算法有索引"><a class="markdownIt-Anchor" href="#nlj算法有索引"></a> NLJ算法（有索引）</h3>
<p>Nested-Loop Join<br />
一次一行地循环从驱动表中读取行，根据关联字段从被驱动表中取出满足条件的行，然后取合集。（磁盘扫描）<br />
由于使用了索引，不需要全表扫描，扫描量较少。</p>
<ul>
<li>inner join：Mysql会自动优化，将更小的表作为驱动表，扫描更少的行数完成任务</li>
<li>left join：左表为驱动表</li>
<li>right join：右表为驱动表</li>
</ul>
<p>Extra没有出现<code>Using join buffer</code>一般就是使用NLJ算法，<strong>如果使用的条件没有建立索引，使用NLJ性能较低，mysql会选择使用BNL算法</strong>。</p>
<h3 id="bnl算法无索引"><a class="markdownIt-Anchor" href="#bnl算法无索引"></a> BNL算法（无索引）</h3>
<p>Block Nested-Loop Join<br />
将驱动表的数据全部放入<code>join buffer</code>（这块空间在内存里面），然后将被驱动表每一行拿出来与<code>join buffer</code>比对。<br />
这个过程中，两张表都会做全表扫描（磁盘扫描），然后在<code>join buffer</code>（内存）中比对；如果驱动表太大，要放2次，那么被驱动表也会被全表扫描2次！</p>
<p>比较上面两种算法，使用到join关联查询时，最好走索引。<br />
尽量<strong>小表驱动大表</strong>，可以用<code>straight_join</code>中指定驱动表（只适用于inner join）；注意这里说的“小表”，是根据条件过滤出来数据量更少的表</p>
<h2 id="in与exist"><a class="markdownIt-Anchor" href="#in与exist"></a> in与exist</h2>
<blockquote>
<p>小表驱动大表</p>
</blockquote>
<h3 id="in子句内的查询会先执行"><a class="markdownIt-Anchor" href="#in子句内的查询会先执行"></a> in子句内的查询会先执行。</h3>
<p>当B表数据量小于A表，in优于exist。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> if <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> B) </span><br><span class="line"><span class="comment">-- 先执行B表查询</span></span><br><span class="line"><span class="comment">-- 相当于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">select</span> id <span class="keyword">from</span> B) &#123;</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> A.id <span class="operator">=</span> B.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽量避免in操作，把in的范围控制在1000以内。</p>
<h3 id="exists外层的语句会先执行"><a class="markdownIt-Anchor" href="#exists外层的语句会先执行"></a> exists外层的语句会先执行</h3>
<p>当A表数据量小于B表，exists优于in。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id <span class="operator">=</span> A.id)</span><br><span class="line"><span class="comment">-- 先执行A表查询</span></span><br><span class="line"><span class="comment">-- 相当于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">select</span> id <span class="keyword">from</span> A) &#123;</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id <span class="operator">=</span> A.id</span><br></pre></td></tr></table></figure>
<p>exists子查询有时候可以用join来代替。</p>
<h2 id="count"><a class="markdownIt-Anchor" href="#count"></a> count</h2>
<p>统计数据量：count(*)效率更高（有专门优化，而且会统计null行），其他方法有索引的、索引小的更快</p>
<h2 id="什么时候分库分表"><a class="markdownIt-Anchor" href="#什么时候分库分表"></a> 什么时候分库分表</h2>
<p>单表行数超过500万行/单表容量超过2GB</p>
<h2 id="索引规约"><a class="markdownIt-Anchor" href="#索引规约"></a> 索引规约</h2>
<ol>
<li>唯一特性字段，在数据库层面就用唯一索引，根本避免脏数据。</li>
<li>超过3张表不要用join；需要用到join，数据类型严格一致；多表查询，关联字段要有索引。（用Java做，Java集群可以提高性能，而MySQL不容易拓展）</li>
<li>varchar索引只建立20长度就可以了。</li>
<li>搜索，严禁左模糊、全模糊，如果需要可以调用搜索引擎（ES）</li>
</ol>
<h1 id="事务和锁"><a class="markdownIt-Anchor" href="#事务和锁"></a> 事务和锁</h1>
<h2 id="并发事务处理的问题"><a class="markdownIt-Anchor" href="#并发事务处理的问题"></a> 并发事务处理的问题</h2>
<ul>
<li>更新丢失：多个事务选择同一行，并基于最初始的值更新该行。最后的更新会覆盖之前的更新。</li>
<li>脏读：一个事务正在修改一条记录，此时另一个事务读取了未提交、未更新的数据。</li>
<li>不可重读：一个事务内部的相同查询语句在不同时刻读出的结果不一致（数据被改变/删除）。</li>
<li>幻读：一个事务按相同查询条件重新读取以前检索过的数据，却发现其他事务插入了新的符合条件的数据。</li>
</ul>
<h2 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h2>
<p>通过设置隔离级别，可以避免上述问题</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>读已提交</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>可重复读</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>可串行化</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>然而隔离级别越高，对性能影响越大；实际上隔离就是使事务串行化，而不是并发。<br />
mysql默认开启可重复读。此时，一个事务，从数据库读取的数据始终一致（实际值会变，只是select使用历史旧版本），但是更新值时不会出错（使用实际值，insert、update、delete使用当前版本）。使用了MVCC机制。<strong>然而，当我们在Java中使用这个读出来的历史版本计算，就会出问题</strong>.<br />
在可串行化级别中，select语句会加写锁。</p>
<h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2>
<ul>
<li>乐观锁：使用版本号比对（性能较好）</li>
<li>悲观锁
<ul>
<li>读锁（Shared）：读操作可以同时进行不受影响</li>
<li>写锁（eXclusive）：当前写操作未完成，会阻断其他写锁、读锁</li>
</ul>
</li>
<li>表锁：锁住整张表，一般用于整表数据迁移，并发程度最低。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock <span class="keyword">table</span> your_table read, your_table2 write;</span><br><span class="line"><span class="comment">-- 显示为1即加了锁</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<ul>
<li>行锁：只锁一行数据，开销大；加锁慢，会出现死锁；并发程度高。</li>
</ul>
<h2 id="间隙锁-某些情况下解决幻读问题"><a class="markdownIt-Anchor" href="#间隙锁-某些情况下解决幻读问题"></a> 间隙锁 某些情况下解决幻读问题</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># id # name</span><br><span class="line">    <span class="number">1</span> name1</span><br><span class="line">    <span class="number">2</span> name2</span><br><span class="line">    <span class="number">10</span> name3</span><br><span class="line">    <span class="number">20</span> name4</span><br><span class="line"><span class="comment">-- 有(2, 10), (10, 20), (20, inf)三个区间</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;your_name&#x27;</span> whre id <span class="operator">&gt;</span> <span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&lt;</span> <span class="number">18</span></span><br><span class="line"><span class="comment">-- (8-18)，覆盖了(2,10), (10, 20)两个区间，(2, 20)区间都会上写锁</span></span><br></pre></td></tr></table></figure>
<p>间隙锁只有在可重复读级别下才生效。</p>
<h2 id="临键锁"><a class="markdownIt-Anchor" href="#临键锁"></a> 临键锁</h2>
<p>临键锁（Next-key Locks）是行锁与间隙锁的结合。</p>
<h2 id="行锁分析"><a class="markdownIt-Anchor" href="#行锁分析"></a> 行锁分析</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>lock_time_avg</code>：平均等待时长</li>
<li><code>lock_waits</code>：等待次数</li>
<li><code>lock_time</code>：等待总时长</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> INFORMATION_SCHEMA INNODB_TRX;</span><br><span class="line"><span class="comment">-- 释放锁</span></span><br><span class="line">kill <span class="operator">&lt;</span>trx_mysql_thread_id<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> INFORMATION_SCHEMA INNODB_LOCKS;</span><br><span class="line"><span class="comment">-- 查看锁等待</span></span><br><span class="line">                                 INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure>
<h2 id="锁优化总结"><a class="markdownIt-Anchor" href="#锁优化总结"></a> 锁优化总结</h2>
<ul>
<li>尽量让数据检索通过索引完成，避免行锁升级为表锁。</li>
<li>合理设计索引，缩小锁的范围</li>
<li>减少检索范围，避免间隙锁</li>
<li>控制事务大小，减少锁定资源量和时长，设计事务加锁的sql尽量放到最后执行</li>
<li>尽可能第级别事务隔离</li>
</ul>
<h1 id="mvcc"><a class="markdownIt-Anchor" href="#mvcc"></a> MVCC</h1>
<p>Multi-Version Concurrency Control多版本并发控制<br />
Mysql读已提交和可重复读两个隔离级别实现了MVCC</p>
<h2 id="undo日志"><a class="markdownIt-Anchor" href="#undo日志"></a> undo日志</h2>
<p>一行数据被多个事务依次修改，每个日志修改成功，都会保留undo日志，用指针表串联</p>
<ul>
<li>事务id：只有第一条<strong>修改</strong>语句被执行，才会真正分配事务id（select不会）</li>
</ul>
<h2 id="read-view"><a class="markdownIt-Anchor" href="#read-view"></a> read-view</h2>
<p>事务开启后，执行任何查询sql时会生成当前事务一致性视图readview，这个值在事务结束前不会变化。<br />
readview由<strong>未提交的事务id数组</strong>与<strong>已创建</strong>的最大事务id组成。</p>
<blockquote>
<p>事务里任何sql查询结果都需要从对应版本链最新数据开始，逐条与read-review做比对</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Trac10: </span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> col1 xxxx <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">Trac20:</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> col2 yyyy <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">Trac30:</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> name thename <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">Trac(temp): <span class="comment">-- 只有update语句才会分配id</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="comment">-- 查询结果为thename </span></span><br><span class="line"><span class="comment">-- read-view: [10, 20]未提交id, 30已创建最大id</span></span><br><span class="line"><span class="comment">-- 此时，10前的id，都是已提交事务；20后的id，都是未提交事务；30后的事务，还没开始</span></span><br><span class="line"><span class="comment">-- 注意，已提交的事务30，不一定小于20</span></span><br><span class="line">Trac10:</span><br><span class="line"><span class="keyword">update</span> name namenew <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">Trac(temp):</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="comment">-- 查询结果还是为thename，Trac10不可见</span></span><br><span class="line">Trac10:</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">Trac(temp):</span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="comment">-- 查询结果为thename！因为read-review保持不变</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>已提交事务</th>
<th>未提交+已提交事务</th>
<th>未开始</th>
</tr>
</thead>
<tbody>
<tr>
<td>10之前</td>
<td>min_id-max_id</td>
<td>30之后</td>
</tr>
</tbody>
</table>
<p>版本链比对规则：</p>
<ol>
<li>行事务trx_id &lt; min_id（已提交），可见</li>
<li>trx_id &gt; max_id（未开始），不可见</li>
<li>trx_id在数组中（未提交），不可见。</li>
<li>trx_id = max_id或不属于数组（已提交），可见。</li>
</ol>
<p>读已提交，和可重复读的read-view的区别：<br />
读已提交：每次查询都会生成最新的read-view，每次都取最新数据。</p>
<h1 id="mysql执行过程"><a class="markdownIt-Anchor" href="#mysql执行过程"></a> Mysql执行过程</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql语句.update t set name=&quot;new_name&quot; where id = 1 -&gt; server层.连接器</span><br><span class="line">server层: &#123;</span><br><span class="line">    连接器 -&gt; 分析器 -&gt; 优化器 -&gt; 执行器</span><br><span class="line">    连接器 -&gt; 查询缓存</span><br><span class="line">    binlog文件</span><br><span class="line">&#125;</span><br><span class="line">server层.执行器 -&gt; InnoDB存储引擎</span><br><span class="line">InnoDB存储引擎 :&#123;</span><br><span class="line">    Buffer Pool缓存池</span><br><span class="line">    Redo Log Buffer</span><br><span class="line">    undo日志文件</span><br><span class="line">    redo日志文件</span><br><span class="line">&#125;</span><br><span class="line">ibd磁盘文件.page.name=old_name -&gt; InnoDB存储引擎.Buffer Pool缓存池: 1. 加载缓存数据（id为1的记录所在的page数据）</span><br><span class="line">InnoDB存储引擎.Buffer Pool缓存池 -&gt; InnoDB存储引擎.undo日志文件: 2. 写入更新前数据的旧值，便于回滚</span><br><span class="line">server层.执行器 -&gt; InnoDB存储引擎.Buffer Pool缓存池: 3. 更新内存数据old_name为new_name</span><br><span class="line">server层.执行器 -&gt; InnoDB存储引擎.Redo Log Buffer: 4. 写redo日志</span><br><span class="line">InnoDB存储引擎.Redo Log Buffer -&gt; InnoDB存储引擎.redo日志文件.name=new_name: 5. 准备提交事务，redo日志写入磁盘</span><br><span class="line">server层.执行器 -&gt; server层.binlog文件: 6. 准备提交事务，binlog日志写入磁盘</span><br><span class="line">server层.binlog文件 -&gt; InnoDB存储引擎.redo日志文件: 7. 写入commit标记到redo日志文件（保证redo与binlog数据一致），标志事务完成</span><br><span class="line">InnoDB存储引擎.Buffer Pool缓存池 -&gt; ibd磁盘文件: 通过IO线程，统一以page为单位写入磁盘</span><br></pre></td></tr></table></figure>
<p>这一套机制保证了读写性能：首先通过顺序IO（利用缓存局部性，性能高）将语句操作写入磁盘的日志文件，最后再通过IO线程通过随机IO，将数据以页为单位写入磁盘ibd。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%9F%A5%E8%AF%86/" rel="tag"># 知识</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/ComputerScience/%E7%AC%94%E8%AE%B0/%E9%94%99%E9%A2%98%E6%9C%AC/MarsCode%20%E9%94%99%E9%A2%98%E6%9C%AC/" rel="prev" title="MarsCode 错题本">
                  <i class="fa fa-angle-left"></i> MarsCode 错题本
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/ComputerScience/%E7%AC%94%E8%AE%B0/%E9%94%99%E9%A2%98%E6%9C%AC/%E6%B4%9B%E8%B0%B7%20%E9%94%99%E9%A2%98%E6%9C%AC/" rel="next" title="洛谷 错题本">
                  洛谷 错题本 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-solid fa-pen-nib"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SIMULEITE</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
